=== Claude Work Log ===

[2025-10-19] Analysis of Biddable App Structure
- Analyzed project structure: Next.js 14 app with TypeScript
- Reviewed core components: Navigation, Dashboard, Asset Creator, Reporting
- Reviewed dependencies: Using shadcn/ui components, react-hook-form, zod
- Current state: No authentication implemented
- Task: Provide recommendations for adding Supabase authentication

[2025-10-19] Auth Implementation Plan Created
- Requirements gathered: email/password, invite-only, multi-org access
- Created .env.local.example with Supabase config
- Planning full authentication implementation
- Updated approach: Using anon/publishable key with RLS policies (best practice)

[2025-10-19] Auth Implementation Completed
- Installed @supabase/supabase-js and @supabase/ssr packages
- Created Supabase client utilities (client.ts and server.ts)
- Created auth helper functions in lib/auth.ts
- Created AuthProvider context for managing auth state
- Created login page (/login)
- Created signup page (/signup)
- Created middleware for route protection
- Updated root layout with AuthProvider
- Updated navigation with user email display and logout button
- Created SUPABASE_SETUP.md with database schema and RLS policies

[2025-10-19] Simplified Auth Setup (Removed Invite System)
- Removed invites table from SUPABASE_SETUP.md
- Removed invite code validation from signUp function
- Simplified signup page to remove invite code field
- Users will be created manually in Supabase Dashboard for speed
- SUPABASE_SETUP.md now contains SQL to create TESTORG and add ops@getbiddable.com
- Note: User needs to create .env.local with real Supabase credentials
- Note: User needs to run SQL commands from SUPABASE_SETUP.md in Supabase dashboard

[2025-10-19] Created Handoff Document for Asset Creator Backend
- Created HANDOFF_ASSET_CREATOR.md with full implementation guide
- Includes database schema, storage setup, API routes, and frontend updates
- Documented data structure, RLS policies, and testing checklist
- Ready for next team to implement file uploads and asset management

[2025-10-19] Google Search Ads Text Ad System Implementation
- Created database migration: supabase/migrations/create_assets_table.sql
  - Assets table with support for images, videos, and text ads
  - Added ad_format field (rsa, eta, generic) for Google Search Ad types
  - Added ad_data JSONB field for storing structured text ad data
  - RLS policies ensure users can only access assets from their organization
  - Indexes on organization_id, type, and status for query performance

- Created text ad validation library: lib/text-ads.ts
  - Character limits for RSA (15 headlines, 4 descriptions) and ETA (3 headlines, 2 descriptions)
  - validateTextAd() function to check all format requirements
  - Helper functions: getCharacterLimit(), getMaxItems(), formatTextAdForDisplay()
  - URL validation for final URLs

- Created text ad form component: components/text-ad-form.tsx
  - Dynamic form that adapts to selected ad format (RSA/ETA/Generic)
  - Add/remove headlines and descriptions with character counters
  - Real-time validation with color-coded character counts
  - Display path fields for URL customization
  - Error display for validation failures
  - Callbacks for submit and preview actions

- Created Google Search preview component: components/google-search-preview.tsx
  - Realistic Google Search results preview
  - Shows how ad appears with headlines, descriptions, and display URL
  - Adapts display for RSA (rotated combinations) vs ETA (fixed)
  - Empty state for when no content is entered
  - Informational notes about ad behavior

- Integrated components into asset-creator-content.tsx
  - Added TextAdForm component for text asset type
  - Added GoogleSearchPreview component to preview panel
  - Wired up submit and preview handlers
  - Text ad form now replaces simple textarea when "text" asset type is selected
  - Fixed duplicate "Asset Name" field - only shows for image/video, not text (TextAdForm has its own)

- Created API route for assets: app/api/assets/route.ts
  - POST endpoint creates new assets in database
  - GET endpoint fetches all assets for user's organization
  - Authenticates user and gets organization from organization_members table
  - Validates required fields and handles errors
  - Returns created asset data on success

- Updated asset-creator-content.tsx with API integration
  - handleTextAdSubmit now calls /api/assets POST endpoint
  - Sends ad_format, ad_data JSONB, and metadata to database
  - Handles success and error responses with user feedback

Ready to test: Create a text ad and verify it saves to the assets table

- Created SQL to add user to organization: supabase/migrations/add_user_to_testorg.sql
  - Adds ops@getbiddable.com to TEST ORG as admin
  - Handles errors if user or org not found
  - Uses ON CONFLICT to avoid duplicates

- Fixed 401 Unauthorized error in API route
  - Changed from browser client to server client in app/api/assets/route.ts
  - Server client properly reads authentication cookies
  - Browser client doesn't work in API routes (server-side)

- Created complete organization setup SQL: supabase/migrations/setup_organizations.sql
  - Creates organizations table with RLS policies
  - Creates organization_members table with RLS policies
  - Inserts TEST ORG organization
  - Adds ops@getbiddable.com to TEST ORG as admin
  - Handles cases where tables already exist (IF NOT EXISTS)
  - User must be signed up in auth.users first before running this

- Added debug logging to API route
  - Logs authenticated user email and ID
  - Logs organization query results
  - Returns detailed error with userId when org not found
  - Check server console logs to see what's happening

- Fixed infinite recursion in RLS policies
  - Created fix_organization_policies.sql (didn't work - policies still exist)
  - Problem: organization_members policy was creating circular reference
  - Solution: Simple policy that just checks user_id = auth.uid()
  - No subqueries needed for organization_members SELECT policy

- Created comprehensive policy reset: reset_all_policies.sql
  - Disables RLS temporarily
  - Drops ALL policies using dynamic SQL loop
  - Re-enables RLS
  - Creates clean, simple policies with no recursion
  - organization_members: just checks user_id = auth.uid()
  - organizations: uses EXISTS with subquery (safe because org_members policy is simple)
  - Includes verification query at end to show what policies exist
  - SUCCESS: Text ads now save to database correctly

[2025-10-19] Google Search Ads Text Ad System - COMPLETED
- Full implementation from database to UI working
- Users can create RSA, ETA, and generic text ads
- Character limits enforced with real-time validation
- Google Search preview shows realistic ad appearance
- Assets save to database with organization scoping
- All RLS policies working correctly

[2025-10-19] AI Image Generation Planning
- Created comprehensive plan: AI_IMAGE_GENERATION_PLAN.md
- Workflow: User enters prompt â†’ Create DB record â†’ Trigger n8n webhook â†’ Poll for completion
- Database additions needed: ai_prompt and generation_status columns
- n8n handles actual image generation and updates file_url when complete
- Frontend polls every 3 seconds for status updates
- Status messages: "Saving...", "Triggering AI...", "Generating...", "Ready!"
- Need to create: AIImageForm component, generate-image API route, polling logic
- Asset library will display all images with their URLs from database

[2025-10-21] User Profile Page Implementation
- Created profile page at /app/profile/page.tsx
- Created ProfileContent component (components/profile-content.tsx)
  - Displays user information (email, user ID)
  - Shows all organizations user belongs to with roles
  - Displays account status and creation date
  - Empty state when user has no organizations
- Created /api/profile API route
  - Fetches user data from Supabase auth
  - Queries organization_members table joined with organizations table
  - Returns user's organizations with id, name, and role
- Updated navigation component (components/navigation.tsx)
  - Made user avatar/email clickable
  - Links to /profile page
  - Added hover state for better UX
- Fixed .gitignore to exclude .next directory
  - Added .next to .gitignore
  - Removed .next from git tracking with git rm -r --cached
- User organization membership confirmed working
  - organization_members table is the source of truth for user-org relationships
  - Table structure: user_id, organization_id, role
  - Manual user addition to orgs done via INSERT into organization_members

[2025-10-21] Asset Library and Image Upload Implementation
- Renamed "Asset Creator" to "Creative" throughout the app
  - Updated navigation.tsx sidebar menu
  - Updated page title in asset-creator-content.tsx
- Implemented Asset Library with table view
  - Replaced card grid layout with clean table with thin rows
  - Table columns: Preview, Type, Name, Format, Status, Created, Created By, Actions
  - Preview column shows 64x64px image thumbnails
  - Actions column has "View" button to open full-size images in new tab
  - Fetches real assets from /api/assets endpoint
  - Filters assets by user's organization (organization-scoped)
  - Loading and empty states
  - Hover effects on rows for better UX
  - Status badges with color coding (green=approved, yellow=draft, red=rejected)
- Image upload functionality (based on bkt.py reference)
  - Created /app/api/assets/upload-image/route.ts
    - Uploads images to Supabase Storage bucket 'biddable-images'
    - Organizes by organization: {organization_id}/{timestamp}-{filename}
    - Gets public URL from Supabase
    - Saves asset record to database with file_url
    - Handles errors and rollback (deletes from storage if DB insert fails)
  - Created ImageUploadForm component (components/image-upload-form.tsx)
    - Drag & drop file upload support
    - Live image preview before upload
    - Auto-detects image format (JPG, PNG, WebP, GIF, SVG)
    - Upload progress indicator
    - File validation (images only)
  - Integrated into Creative page
    - Shows ImageUploadForm when "Image" asset type is selected
    - Auto-refreshes Asset Library after successful upload
  - Updated .env.local.example
    - Added NEXT_PUBLIC_SUPABASE_STORAGE_BUCKET=biddable-images
- Supabase Storage setup completed
  - Bucket name: biddable-images
  - Made bucket public for public URL access
  - Created RLS policies for organization-based access control
    - Users can INSERT to their org folder
    - Users can SELECT from their org folder
    - Users can UPDATE/DELETE in their org folder
  - Policy structure uses storage.foldername(name)[1] to check org ID
- Created IMAGE_UPLOAD_SETUP.md documentation
- Image upload fully functional and tested
  - Images upload to Supabase Storage successfully
  - Public URLs generated and saved to database
  - Thumbnails display in Asset Library
  - Full images viewable via "View" button

[2025-10-21] Chat Widget Markdown Rendering
- Added markdown rendering support to chatbot
  - Installed react-markdown (v9.0.1) and remark-gfm (v4.0.0)
  - Updated package.json with new dependencies
- Updated chat-widget.tsx (components/chat-widget.tsx)
  - Assistant messages now render markdown properly
  - User messages remain plain text
  - Custom component styling for markdown elements:
    - Headings (h1, h2, h3) with appropriate sizing
    - Lists (ul, ol) with proper indentation
    - Code blocks (inline and multi-line) with background styling
    - Blockquotes with left border
    - Bold and italic text
  - Added rounded corners to message bubbles for better UX
- Updated next.config.mjs
  - Added transpilePackages for react-markdown and remark-gfm
- Markdown features now supported:
  - Headings, bold, italic, strikethrough
  - Bullet and numbered lists
  - Code blocks (inline and fenced)
  - Blockquotes
  - Links
  - Tables (via GitHub Flavored Markdown)
  - Task lists
- Fully tested and working

[2025-10-21] Campaign Detail Pages Implementation
- Created API endpoint at /api/campaigns/[id]/route.ts
  - GET endpoint retrieves single campaign by ID
  - Validates campaign ID is a number
  - Ensures user owns campaign (created_by = user.id)
  - Returns 404 if campaign not found or access denied
  - Returns 401 if user not authenticated
- Created CampaignDetailContent component (components/campaign-detail-content.tsx)
  - Fetches campaign data from API endpoint
  - Displays comprehensive campaign information:
    - Campaign header with name, status badge, ID, and creation date
    - Key metrics cards: Budget, Spent, Collected, Media Fee
    - Campaign information card: Platforms, Goal, Duration, Status
    - Payment information card: Payment status, Subscription plan, Stripe ID, Payment date
    - Budget usage progress bar with color coding (green < 70%, yellow < 90%, red >= 90%)
  - Loading and error states with user-friendly messages
  - Back to campaigns button for easy navigation
  - Edit and Delete buttons (currently disabled, placeholders for future)
- Created dynamic route page at /app/campaigns/[id]/page.tsx
  - Uses Next.js 14 dynamic routing with [id] parameter
  - Follows same layout pattern as other pages (Navigation sidebar + content)
  - Passes campaign ID to CampaignDetailContent component
- Updated campaigns-content.tsx
  - Campaign names in table are now clickable links
  - Links navigate to /campaigns/[id] for detail view
  - Styled with primary color and hover underline
- Middleware protection already covers /campaigns/[id] routes
  - No changes needed - existing middleware protects all /campaigns/* paths
- Campaign detail pages fully functional
  - Users can click campaign name to view details
  - URL structure: /campaigns/123
  - Organization-scoped access control via created_by field
  - Ready for future enhancements (edit, delete, analytics)

[2025-10-21] Campaign-Asset Assignment System Implementation
- Created campaign_assets junction table (supabase/migrations/create_campaign_assets_table.sql)
  - Many-to-many relationship between campaigns and assets
  - Allows one campaign to have multiple assets
  - Allows one asset to be used in multiple campaigns
  - Fields: id, campaign_id, asset_id, assigned_by, assigned_at
  - Unique constraint prevents duplicate assignments
  - Cascading deletes when campaign or asset is deleted
  - RLS policies:
    - Users can view assignments for campaigns they created
    - Users can assign assets from their organization to their campaigns
    - Users can unassign assets from their campaigns
  - Indexes on campaign_id, asset_id, and assigned_by for performance
- Created API endpoints at /api/campaigns/[id]/assets/route.ts
  - GET: Fetch all assets assigned to a campaign
    - Returns assets with full details via join
    - Ordered by assigned_at (newest first)
    - Validates user owns the campaign
  - POST: Assign an asset to a campaign
    - Validates campaign ownership
    - Validates asset exists and is in user's organization
    - Prevents duplicate assignments (409 error)
    - Returns assignment record on success
  - DELETE: Unassign an asset from a campaign
    - Takes asset_id as query parameter
    - Validates campaign ownership
    - Removes assignment from junction table
- Updated CampaignDetailContent component (components/campaign-detail-content.tsx)
  - Added "Assigned Creative" section to campaign detail page
  - Fetches assigned assets on page load
  - Fetches all available assets from organization
  - Asset assignment dialog:
    - Shows all assets in organization
    - Displays preview thumbnails for images
    - Shows asset type, format, status
    - "Already Assigned" badge for assets already in campaign
    - Assign button for unassigned assets
    - Loading state while assigning
  - Assigned assets table:
    - Shows preview thumbnails
    - Displays name, type, format, status, assigned date
    - Unassign button (X icon) to remove from campaign
    - Empty state with call-to-action when no assets assigned
  - Asset type icons (image, video, text) for non-image assets
  - Confirmation dialog before unassigning
- Campaign-asset relationship fully functional
  - Users can assign creative from their organization to campaigns
  - Users can unassign creative from campaigns
  - Assets can be reused across multiple campaigns
  - All operations protected by RLS and API validation
  - Ready for testing with real data
- Fixed asset_id type mismatch in SQL migration
  - Changed asset_id from BIGINT to UUID to match assets table schema
  - Updated TypeScript interfaces to use string for asset IDs
  - Updated API routes to handle UUID asset IDs correctly
  - SQL migration now runs without errors

[2025-10-21] Audiences Feature Implementation
- Created audiences table (supabase/migrations/create_audiences_table.sql)
  - UUID primary key for audience records
  - Organization-scoped audiences (organization_id)
  - Demographic targeting: age_min, age_max, genders (array)
  - Geographic targeting: locations (array)
  - Interest & behavior targeting: interests (array), behaviors (array)
  - JSONB targeting_criteria field for platform-specific targeting
  - estimated_size field for audience size
  - status field (active/archived)
  - Auto-updating updated_at timestamp via trigger
  - Age constraints (13-100, max >= min)
  - RLS policies for organization-based access (SELECT, INSERT, UPDATE, DELETE)
  - GIN indexes on arrays and JSONB for fast searching
- Created campaign_audiences junction table (supabase/migrations/create_campaign_audiences_table.sql)
  - Many-to-many relationship between campaigns and audiences
  - Fields: id, campaign_id (BIGINT), audience_id (UUID), assigned_by, assigned_at
  - Cascading deletes for data integrity
  - RLS policies for campaign ownership and org membership
  - Unique constraint prevents duplicate assignments
- Created API endpoints at /api/audiences/[id]/route.ts
  - GET: Fetch single audience by ID
    - Validates organization membership
    - Returns full audience data
  - PUT: Update audience
    - Validates organization membership
    - Updates any provided fields
    - Auto-updates updated_at timestamp
  - DELETE: Archive audience (soft delete)
    - Sets status to 'archived'
    - Validates organization membership
- Created AudienceDetailContent component (components/audience-detail-content.tsx)
  - View/edit mode with inline editing
  - Displays all audience targeting criteria
  - Edit functionality for all fields (name, description, demographics, locations, interests, behaviors)
  - Comma-separated input for arrays
  - Real-time form validation
  - Save/Cancel buttons
  - Archive button with confirmation
  - Key metrics cards (Estimated Size, Locations count, Interests count)
  - Organized sections: Basic Info, Demographics, Geographic, Interest & Behavior
  - Back navigation to audiences list
- Created dynamic route page at /app/audiences/[id]/page.tsx
  - Uses Next.js 14 dynamic routing with [id] parameter
  - Same layout pattern (Navigation + content)
- Made audience names clickable in audiences-content.tsx
  - Links navigate to /audiences/[id]
  - Styled with primary color and hover underline
- Created API endpoints at /api/campaigns/[id]/audiences/route.ts
  - GET: Fetch all audiences assigned to a campaign
    - Returns audiences with full details via join
    - Validates campaign ownership
  - POST: Assign an audience to a campaign
    - Validates campaign ownership and org membership
    - Prevents duplicate assignments (409 error)
  - DELETE: Unassign an audience from a campaign
    - Takes audience_id as query parameter
    - Validates campaign ownership
- Updated CampaignDetailContent component with audience assignment
  - Added "Assigned Audiences" section to campaign detail page
  - Fetches assigned and available audiences on page load
  - Audience assignment dialog:
    - Shows all audiences in organization
    - Displays age range, locations, interests, estimated size
    - "Already Assigned" badge for assigned audiences
    - Assign button with loading state
  - Assigned audiences table:
    - Clickable audience names (link to detail page)
    - Shows description, age range, locations, interests, estimated size
    - Assigned date
    - Unassign button (X icon)
    - Empty state with call-to-action
  - formatNumber helper for displaying large numbers (K, M notation)
- Full audiences workflow complete:
  - Create audiences with targeting criteria
  - View/edit audience details on dedicated pages
  - Assign audiences to campaigns
  - Unassign audiences from campaigns
  - Audiences can be reused across multiple campaigns
  - All operations protected by RLS and organization scoping
- Documentation created: AUDIENCES_SETUP.md
  - Complete setup guide with SQL migrations
  - Field descriptions and constraints
  - Array and JSONB usage examples
  - API endpoint documentation
  - Testing checklist
  - Troubleshooting guide

[2025-10-21] Convert Audience IDs from UUID to BIGINT (int8)
- Reason: Consistency with campaigns table and better UX
  - Long UUIDs in URLs are cumbersome to copy (must copy in segments)
  - BIGINT IDs (like campaigns) can be copied with one double-click
  - Power users of ad platforms expect simple numeric IDs
- Created SQL migration: convert_audience_id_to_bigint.sql
  - Drops and recreates audiences table with BIGSERIAL ID
  - Drops and recreates campaign_audiences junction table with BIGINT audience_id
  - Preserves all table structure, constraints, indexes, and RLS policies
  - Note: Existing test data will be deleted (acceptable at this stage)
- Updated all TypeScript interfaces to use number instead of string:
  - components/audience-detail-content.tsx
  - components/audiences-content.tsx
  - components/campaign-detail-content.tsx (Audience and CampaignAudience interfaces)
- Updated API routes to handle BIGINT IDs:
  - app/api/audiences/[id]/route.ts (GET, PUT, DELETE)
    - Added ID validation (isNaN check)
  - app/api/campaigns/[id]/audiences/route.ts (POST, DELETE)
    - Convert audience_id to Number() before database operations
- All audience URLs now use simple numeric IDs: /audiences/123
- IDs are now consistent across the platform:
  - Campaigns: BIGINT
  - Audiences: BIGINT
  - Assets: UUID (appropriate for creative files)

[2025-10-24] AI Image Generation Feature Implementation
- Created AI-powered image generation system for creative assets
- Workflow: User submits form â†’ n8n generates image â†’ Response with Supabase Storage location â†’ Display image
- Components and API routes created:
  - Created components/ai-image-form.tsx
    - Form with Product and Brand input fields
    - Submits data to backend API
    - Handles n8n response with image location
    - Displays generated image with preview
    - Shows success state with download and "Generate Another" buttons
    - Error handling with user-friendly messages
  - Created app/api/ai-generate/route.ts (proxy to avoid CORS)
    - Proxies requests from frontend to n8n webhook
    - Avoids CORS issues between localhost and n8n cloud
    - Returns n8n response to frontend
  - Updated components/asset-creator-content.tsx
    - Added "AI Generate" as 4th asset type alongside Image, Video, Text
    - 2x2 grid layout for asset type buttons
    - Integrated AIImageForm component
    - Custom preview panel explaining AI generation process
    - Sparkles icon throughout for AI branding
- n8n Integration:
  - Webhook URL: https://biddable.app.n8n.cloud/webhook-test/7cca0f58-831a-46af-ab24-fbc86b01bbfc
  - Request payload format: { Product, "Your Brand", submittedAt, formMode }
  - Response format: { "folder/filename": "biddable-images/...", "Id": "..." }
  - Handles both array and object response formats from n8n
- Image Display and Storage:
  - Parses n8n response to extract bucket name and filename
  - Uses Supabase Storage getPublicUrl() to generate image URL
  - Displays generated image inline with metadata
  - Auto-creates asset record in database after generation
- Asset Library Integration:
  - AI-generated images automatically saved to assets table
  - Asset name format: "AI Generated: {Product} - {Brand}"
  - Type: "image", Format: "PNG", Size: "AI Generated"
  - Includes file_url for thumbnail and full image display
  - Updated app/api/assets/route.ts to accept file_url parameter
  - Thumbnails and "View" buttons work correctly in Asset Library
  - Assets can be assigned to campaigns like any manually uploaded image
- CORS Issue Resolution:
  - Initial implementation hit CORS error (n8n â†’ localhost:3000)
  - Solution: Created Next.js API proxy at /api/ai-generate
  - Flow: Frontend â†’ /api/ai-generate â†’ n8n â†’ response â†’ frontend
  - Server-to-server calls avoid CORS restrictions
- Production Architecture Planning:
  - Created comprehensive handoff document: AI_IMAGE_GENERATION_PRODUCTION.md
  - Documented async/webhook callback architecture for production
  - Includes database schema for ai_image_requests table
  - Polling/WebSocket patterns for real-time status updates
  - Rate limiting, cost tracking, security tokens
  - Complete implementation guide (4-6 hour estimate)
  - Current sync implementation works for testing but has limitations:
    * Blocks for 30-60 seconds during generation
    * Will timeout on serverless platforms (60s limit)
    * No rate limiting or request tracking
  - Production implementation deferred until ready for launch
- Features working:
  - User submits Product and Brand fields
  - n8n generates image via OpenAI/other AI service
  - n8n uploads to Supabase Storage and returns location
  - Frontend displays generated image
  - Asset automatically added to Asset Library
  - Can assign to campaigns immediately
- Testing successful with real AI image generation
- Ready for testing phase, production architecture documented for future implementation

[2025-10-28] Reddit Ad Creation Feature Implementation
- Added complete Reddit ad creation functionality to assets module
- Created components/reddit-ad-form.tsx
  - Form with all Reddit ad fields: name, headline (300 char limit), CTA dropdown, destination URL, display URL
  - Checkboxes: add source parameter, allow comments
  - Image/video upload with drag & drop support
  - Real-time preview updates via onPreview callback
  - Character counter for headline (0/300)
  - CTA options: Download, Install, Shop Now, View More, Sign Up, Learn More, Contact Us, Get Showtimes, Get a Quote
  - Form validation and submission to /api/assets
  - Initially included URL import feature, removed per user request
- Created components/reddit-ad-preview.tsx
  - Live preview component showing realistic Reddit mobile UI
  - Updates in real-time as user types
  - Displays: headline, image/video, CTA button, display URL
  - Reddit post layout with vote/comment/share buttons
  - Uses Reddit's brand color (#FF4500)
  - Initially included bottom navigation bar, removed per user request
- Updated components/asset-creator-content.tsx
  - Added "reddit" to asset type options
  - Added MessageSquare icon for Reddit button (Reddit orange color)
  - Imported RedditAdForm and RedditAdPreview components
  - Added Reddit ad preview state management with useCallback to prevent infinite loops
  - Integrated Reddit form and preview into create asset layout
  - Added library filter functionality (All/Ads/Images)
  - Filter buttons in Asset Library header
  - Smart filtering: "Ads" shows text+reddit_ad, "Images" shows image+video, "All" shows everything
  - Updated empty state messages for filtered views
  - Updated asset library table to display Reddit ads with proper icon and preview
- Created database migration: supabase/migrations/add_reddit_ad_format.sql
  - Updates assets_type_check constraint to include 'reddit_ad' type
  - Updates assets_ad_format_check constraint to include 'reddit_promoted_post' format
  - Allows NULL for ad_format (backward compatibility)
  - User manually ran migration in Supabase dashboard (no SQL executed by Claude)
- Cleaned up migrations folder per user request
  - Deleted: convert_audience_id_to_bigint.sql, create_ai_image_requests_table.sql, create_audiences_table.sql, create_campaign_assets_table.sql, create_campaign_audiences_table.sql
  - Only one migration file remains: add_reddit_ad_format.sql
- Reddit Ad Data Structure:
  - type: "reddit_ad"
  - ad_format: "reddit_promoted_post"
  - ad_data: { headline, callToAction, destinationUrl, displayUrl, addSourceParameter, allowComments, mediaUrl, mediaType }
  - format: "REDDIT"
  - size: "{headline.length} chars"
  - file_url: Supabase storage URL for uploaded media
- Debugging Issues Resolved:
  - Issue 1: Infinite re-render loop
    * Cause: Preview callback function recreated on every render
    * Solution: Wrapped handleRedditAdPreview with useCallback in asset-creator-content.tsx
  - Issue 2: Database constraint violation (ad_format)
    * Error: "new row for relation 'assets' violates check constraint 'assets_ad_format_check'"
    * Initial investigation thought it was ad_format field
    * Created migration to add 'reddit_promoted_post' to allowed values
  - Issue 3: Database constraint violation (type) - ROOT CAUSE
    * Error: "new row for relation 'assets' violates check constraint 'assets_type_check'"
    * Root cause: 'reddit_ad' not in allowed types
    * Solution: Updated migration to fix BOTH constraints (type and ad_format)
    * Fixed: Reddit ads now save successfully to database
- Features Working:
  - Reddit button appears in Create New Asset section
  - Form loads with all required fields
  - File upload via drag & drop and file picker
  - Preview updates in real-time as user types
  - Character counter for headline
  - CTA dropdown with proper formatting (shop_now â†’ "Shop Now")
  - Form submission creates asset successfully
  - Asset appears in library with Reddit icon and thumbnail
  - Asset library filtering (All/Ads/Images) works correctly
  - Image preview displays in library table
  - Reddit ads can be assigned to campaigns like other assets
- Asset Library Enhancement:
  - Added filter buttons: All, Ads, Images
  - "Ads" filter shows only complete multi-element ads (text ads & reddit ads)
  - "Images" filter shows only media files (images & videos)
  - "All" shows everything
  - Filter buttons styled consistently with Create/Library tabs
  - Active filter highlighted with primary color
  - Contextual empty state messages based on active filter
- Reddit ad creation feature fully functional and tested

[2025-10-30] Agentic Buying System - Planning Phase
- Mission: Enable AI agents to manage advertising campaigns through Biddable
- Goals:
  1. Expose well-documented API for agent operations
  2. Support both hosted agent (in-app) and external agents (FastMCP)
  3. Secure interface with API keys and budget controls
- Requirements gathered:
  - Agents update database only (no live ad placement yet)
  - $10,000/month ad spend limit per organization
  - Both hosted agent on platform AND external agents via FastMCP
  - Existing simple chatbot to be upgraded to full agent
- Created comprehensive 3-week implementation plan: agentic-buying-plan.txt
  Week 1: Core Agent API (Next.js REST endpoints)
    - Database tables: api_keys, agent_audit_log
    - API key generation and management system
    - Campaign operations: list, create, get, update, delete, assign assets/audiences
    - Asset operations: list, create text/Reddit ads, upload/generate images
    - Audience operations: list, create, get, update, delete
    - API key management UI in settings
    - 30+ new API endpoints under /api/v1/agent/*
  Week 2: Security, Validation & Monitoring
    - Rate limiting (1000 req/hr per key, per-endpoint limits)
    - Budget validation ($10k/month enforced)
    - Comprehensive input validation with Zod schemas
    - Standardized error responses with error codes
    - Audit logging for all agent actions
    - Audit log viewer UI
    - Agent analytics dashboard
    - OpenAPI/Swagger documentation
    - Interactive API docs with "Try it out"
    - Developer guide (AGENT_API_GUIDE.md)
  Week 3: FastMCP Server & Hosted Agent
    - Python FastMCP server in /fastmcp-server/ directory
    - MCP tool definitions for all operations (20+ tools)
    - HTTP client wrapper for Next.js API
    - Campaign tools: create_campaign, list_campaigns, update_campaign, etc.
    - Asset tools: create_text_ad, create_reddit_ad, generate_ai_image, etc.
    - Audience tools: create_audience, list_audiences, update_audience, etc.
    - Hosted agent (upgraded chat widget with FastMCP integration)
    - Agent conversation storage
    - Claude Desktop integration guide
    - Comprehensive test suite
    - Deployment documentation
- Architecture chosen: Hybrid approach
  - REST API accessible to any agent/system
  - FastMCP wrapper for Claude and MCP-compatible agents
  - Same backend serves both hosted and external agents
- Key technical decisions:
  - API keys with bcrypt hashing
  - Scoped permissions per key
  - Request ID tracking for debugging
  - Async audit logging (non-blocking)
  - Budget validation on every campaign operation
  - OpenAPI spec for universal compatibility
- Security considerations:
  - API key authentication (Bearer token)
  - Rate limiting per key and per endpoint
  - Input validation with Zod
  - Audit logging for compliance
  - Key rotation support
  - Automatic key expiration
- Future enhancements documented:
  - Phase 2: Advanced workflows, agent marketplace, webhooks
  - Phase 3: Live ad platform APIs, real-time performance data
- Documentation created: agentic-buying-plan.txt
  - 800+ lines of comprehensive planning
  - Week-by-week breakdown with daily tasks
  - Technical specifications
  - Testing strategy
  - Risk mitigation
  - Example API requests/responses
  - FastMCP tool examples
  - Claude Desktop configuration
- Ready for team review and implementation kickoff

[2025-10-30] Database Schema Verification
- User encountered error: "relation 'organizations' does not exist"
- Created initial migration files for organizations and api_keys tables
- User provided current_db.sql with actual schema dump
- Analysis revealed:
  * Organizations and organization_members tables ALREADY EXIST
  * All core tables exist: campaigns, assets, audiences, junctions
  * Extra tables found: media_plans, campaign_analytics, subscriptions, user_profiles, invites, chat_messages, chat_sessions
  * Only 2 tables needed: api_keys and agent_audit_log
- Updated migration files:
  * Deleted create_organizations_tables.sql (redundant)
  * Updated create_api_keys_table.sql (removed organizations creation)
  * Created create_agent_audit_log_table.sql (new file)
- Schema validation results:
  * 15 tables total in current schema
  * All core tables match plan expectations
  * ID types consistent: campaigns/audiences use BIGINT, assets/orgs use UUID
  * Foreign keys properly configured
  * RLS policies already in place
  * Asset types support: image, video, text, reddit_ad âœ“
  * Ad formats support: rsa, eta, generic, reddit_promoted_post âœ“
- Created SCHEMA_STATUS.md documentation:
  * Complete schema comparison report
  * What exists vs what needs to be created
  * Validation of plan accuracy
  * Step-by-step next actions
  * Decision points for hosted agent (extend chat tables vs new tables)
- Key finding: Existing chat_messages and chat_sessions tables
  * May extend for agent conversations OR
  * Create separate agent_conversations/agent_messages tables
  * Recommendation: Separate tables for cleaner separation
- agentic-buying-plan.txt remains 95% accurate
  * Week 1 Day 1-2 needs minor update (skip org creation)
  * Week 3 should note existing chat system
  * All other technical details are correct
- Status: Ready to run 2 migrations and begin Week 1 implementation
- Next steps: Run create_api_keys_table.sql, then create_agent_audit_log_table.sql

[2025-10-30] Week 1 Day 1-2: API Key Management System Implementation
- Database tables created successfully:
  * api_keys table with bcrypt hashing
  * agent_audit_log table for compliance tracking
- Installed dependencies:
  * bcryptjs for secure key hashing
  * @types/bcryptjs (deprecated but harmless warning)
- Created API key utility library (lib/agent-api-keys.ts):
  * generateApiKey(): Creates keys with format bbl_[32 chars]
  * hashApiKey(): Bcrypt hashing with 10 salt rounds
  * verifyApiKey(): Verify key against hash
  * createApiKey(): Create new API key with organization scoping
  * listApiKeys(): List all keys for organization
  * revokeApiKey(): Deactivate a key
  * deleteApiKey(): Permanently delete a key
  * validateApiKey(): Validate key and update last_used_at
  * updateApiKey(): Update key metadata
- Created API routes for key management:
  * GET /api/settings/api-keys - List all keys
  * POST /api/settings/api-keys - Create new key
  * PATCH /api/settings/api-keys/[id] - Update key
  * DELETE /api/settings/api-keys/[id] - Delete key
  * POST /api/settings/api-keys/[id]/revoke - Revoke key
  * All routes protected by user authentication
  * Organization-scoped access control
- Created API Keys Settings UI (app/settings/api-keys/):
  * Clean table view of all API keys
  * Create new key dialog with form
  * Show generated key ONLY ONCE with copy button
  * Hide/show key toggle for security
  * Revoke and delete actions with confirmations
  * Status badges (Active/Revoked)
  * Last used timestamp tracking
  * Key prefix display (bbl_1234...)
  * Empty state with call-to-action
  * Toast notifications for actions
  * Delete confirmation dialog
- Updated navigation:
  * Added "Settings" menu item with Settings icon
  * Links to /settings/api-keys
  * Active state highlighting for settings routes
  * Rounded corners on navigation items
- Updated middleware:
  * Added /settings to protected routes
  * Requires authentication for all settings pages
- Key features working:
  * Generate random API keys with bbl_ prefix
  * Secure bcrypt hashing (never store plain text)
  * Copy to clipboard functionality
  * Organization-scoped access
  * RLS policies enforce data isolation
  * One-time key display for security
- Ready for testing:
  * User can create API keys via UI
  * Keys stored securely in database
  * Can revoke/delete keys
  * All actions logged with timestamps
- Next steps:
  * Test end-to-end API key creation
  * Create agent API middleware for authentication
  * Build Week 1 Day 3-4: Campaign API endpoints

[2025-10-30] Moved API Key Management to Profile Page
- User requested changes:
  * Move API key management from /settings/api-keys to /profile page
  * Clarify that API keys are organization-wide (shared by all org members)
  * Make any user in the org able to create/manage keys
- Implementation:
  * Integrated API Keys section into profile-content.tsx
  * Added new "Organization API Keys" card to profile page
  * All API key functionality (create, revoke, delete, view) now in profile
  * Clear messaging: "shared across all members of your organization"
  * Notice banner in table view: "These API keys are shared across your entire organization"
  * Updated delete confirmation to mention org-wide impact
- Removed old files:
  * Deleted /app/settings/api-keys/ directory
  * Deleted /components/api-keys-settings.tsx
  * Removed "Settings" menu item from navigation
- Backend unchanged:
  * API routes still at /api/settings/api-keys (working fine)
  * RLS policies already support org-wide access
  * Database structure already has organization_id on api_keys table
- UI improvements:
  * Profile page now has 4 sections: User Info, Organizations, Account Status, API Keys
  * API Keys card with Create button in header
  * Empty state with call-to-action
  * Table view with Name, Key, Status, Last Used, Actions
  * Organization icon in notice banner for clarity
  * Consistent styling with rest of profile page
- Ready for testing:
  * Go to /profile page
  * Scroll to "Organization API Keys" section
  * Create, view, revoke, delete keys
  * All functionality in one place

[2025-10-30] Week 1 Day 3-4: Agent API Middleware & Campaign Endpoints
- Created agent API authentication middleware (lib/agent-api-middleware.ts):
  * authenticateAgentRequest(): Validates Bearer token API keys
  * Extracts Authorization header
  * Calls validateApiKey() to verify and check expiration
  * Updates last_used_at timestamp
  * Returns AgentAuthContext with org ID and permissions
  * Standard error response format with error codes
  * generateRequestId(): Unique tracking for each request
  * createErrorResponse(): Consistent error formatting
  * addAgentApiHeaders(): X-Request-ID and rate limit headers
- Created campaign API endpoints under /api/v1/agent/campaigns/:
  * GET /list - List all campaigns with pagination
    - Query params: limit (max 100), offset, status filter
    - Returns campaigns with asset/audience counts
    - Organization-scoped results
  * POST /create - Create new campaign
    - Zod validation schema for input
    - Required: name, platforms[], budget, start_date, end_date
    - Optional: goal
    - Budget limit: 1-10000 (will add $10k/month validation in Week 2)
    - Date validation: end_date must be after start_date
    - Returns created campaign with 201 status
  * GET /[id]/get - Get single campaign with full details
    - Includes assigned assets and audiences via joins
    - Organization access control
    - Returns 404 if not found or no access
  * PATCH /[id]/update - Update existing campaign
    - All fields optional (partial updates)
    - Date range validation
    - Organization access control
    - Returns updated campaign
  * DELETE /[id]/delete - Delete campaign permanently
    - Cascade deletes campaign_assets and campaign_audiences
    - Organization access control
    - Returns success confirmation
- Authentication flow:
  * Agent sends: Authorization: Bearer bbl_[key]
  * Middleware validates key against database
  * Checks expiration, updates last_used_at
  * Attaches organization context to request
  * All endpoints use same auth pattern
- Error handling:
  * Standard error codes: UNAUTHORIZED, VALIDATION_ERROR, RESOURCE_NOT_FOUND, FORBIDDEN, DATABASE_ERROR, INTERNAL_ERROR
  * Detailed error messages with context
  * Request ID tracking for debugging
  * Field-level validation errors from Zod
- Response format:
  * Success: { success: true, data: {...} }
  * Error: { success: false, error: { code, message, details, timestamp, request_id } }
  * Consistent HTTP status codes
- Security:
  * All endpoints require valid API key
  * Organization-scoped data access
  * No cross-org data leakage
  * User verification via organization_members table
- Ready for testing:
  * Create API key in /profile
  * Use curl or Postman to test endpoints
  * All CRUD operations on campaigns work via agent API
- Next steps:
  * Test with real API key
  * Add asset assignment endpoints
  * Add audience assignment endpoints
  * Build Week 2: Rate limiting and budget validation

[2025-10-31] Fixed RLS Issues & Completed Campaign API Testing
- Critical Issue: RLS policies blocking agent API operations
  * Problem: Using createClient() from @/lib/supabase/server requires authenticated session
  * Agent API authentication is separate (API key validation)
  * RLS policies were blocking because no auth.uid() during API key validation
  * Campaign creation, list, get, update, delete all failing
- Solution: Use service role key to bypass RLS
  * Changed all agent API endpoints to use service role key
  * Import: createClient from '@supabase/supabase-js' (not @/lib/supabase/server)
  * Initialize: createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!)
  * Service role bypasses RLS completely (safe because we implement org-scoping in code)
- Files updated:
  * lib/agent-api-keys.ts - validateApiKey() now uses service role
  * app/api/v1/agent/campaigns/create/route.ts - uses service role
  * app/api/v1/agent/campaigns/list/route.ts - uses service role + org user filtering
  * app/api/v1/agent/campaigns/[id]/get/route.ts - uses service role
  * app/api/v1/agent/campaigns/[id]/update/route.ts - uses service role
  * app/api/v1/agent/campaigns/[id]/delete/route.ts - uses service role
- Organization filtering for campaigns:
  * Campaigns don't have organization_id field (they use created_by user UUID)
  * Solution: Two-step query
    1. Get all user_ids in the organization from organization_members
    2. Filter campaigns by .in('created_by', userIds)
  * Ensures proper data isolation between organizations
- Testing completed with API key: bbl_GJMRw4w6NHyUUfeDNhdv75zYeikhhpc6
  * âœ… CREATE: Created campaign #27 successfully
  * âœ… GET: Retrieved campaign details with assets and audiences
  * âœ… LIST: Retrieved all campaigns (8 total) filtered by organization
  * âœ… UPDATE: Updated campaign name and budget (27 â†’ "Updated Test Campaign", budget 5000 â†’ 7500)
  * âœ… DELETE: Deleted campaign successfully, verified with 404 on subsequent GET
  * âœ… Final test: Created campaign #28 to verify everything works after cleanup
- Removed debug logging from validateApiKey():
  * Cleaned up all console.log statements
  * Production-ready code
- Created testing guide: AGENT_API_TEST_GUIDE.md
  * Complete curl examples for all endpoints
  * Expected responses for success and error cases
  * Error testing scenarios
  * Postman collection instructions
- All 5 campaign CRUD endpoints fully functional
- Week 1 Day 3-4 COMPLETE
- Next steps:
  * Week 1 Day 5-6: Asset assignment endpoints
  * Week 1 Day 7: Audience assignment endpoints
  * Week 2: Rate limiting and budget validation

[2025-10-31] Week 1 Day 5-7: Asset & Audience Assignment Endpoints
- Created asset assignment endpoints (app/api/v1/agent/campaigns/[id]/assets/route.ts)
  * GET /api/v1/agent/campaigns/[id]/assets - List assigned assets with full details
  * POST /api/v1/agent/campaigns/[id]/assets - Assign asset to campaign
  * DELETE /api/v1/agent/campaigns/[id]/assets?asset_id=<uuid> - Unassign asset
  * Organization-scoped access control
  * Service role key usage for RLS bypass
  * Standard agent API error responses
  * Request ID tracking
  * Duplicate detection (409 error if already assigned)
- Created audience assignment endpoints (app/api/v1/agent/campaigns/[id]/audiences/route.ts)
  * GET /api/v1/agent/campaigns/[id]/audiences - List assigned audiences with full details
  * POST /api/v1/agent/campaigns/[id]/audiences - Assign audience to campaign
  * DELETE /api/v1/agent/campaigns/[id]/audiences?audience_id=<number> - Unassign audience
  * Same organization-scoping and security as asset endpoints
  * Audience ID validation (BIGINT, not UUID)
- Created helper endpoints for listing resources:
  * app/api/v1/agent/assets/list/route.ts
    - GET /api/v1/agent/assets/list
    - Query params: limit (max 100), offset, type filter
    - Returns all assets in organization
    - Pagination support
  * app/api/v1/agent/audiences/list/route.ts
    - GET /api/v1/agent/audiences/list
    - Query params: limit (max 100), offset, status filter
    - Returns all audiences in organization
    - Pagination support
- Testing completed with API key: bbl_GJMRw4w6NHyUUfeDNhdv75zYeikhhpc6
  * âœ… LIST assets: Retrieved 12 total assets (5 shown with limit=5)
  * âœ… ASSIGN asset: Assigned asset 00bc7702-b599-4ab3-903d-b952a1dcf303 to campaign 28
  * âœ… GET assigned assets: Verified assignment with full asset details
  * âœ… UNASSIGN asset: Removed assignment successfully
  * âœ… LIST audiences: Retrieved 1 audience (ID: 1)
  * âœ… ASSIGN audience: Assigned audience 1 to campaign 28
  * âœ… GET assigned audiences: Verified assignment with full audience details
  * âœ… UNASSIGN audience: Removed assignment successfully
- All 10 endpoints functional (5 campaign + 3 asset + 2 audience assignment)
- Organization data isolation working correctly
- Asset and audience many-to-many relationships working via junction tables
- Week 1 Day 5-7 COMPLETE
- Agent API Status Summary:
  * Campaign operations: âœ… 5 endpoints (list, create, get, update, delete)
  * Asset assignment: âœ… 4 endpoints (list assets, list assigned, assign, unassign)
  * Audience assignment: âœ… 4 endpoints (list audiences, list assigned, assign, unassign)
  * API key management: âœ… UI in /profile
  * Total: 13 agent API endpoints operational
- Next steps:
  * Week 2: Rate limiting, budget validation, audit logging
  * Week 2: OpenAPI documentation
  * Week 3: FastMCP server implementation

[2025-10-31] Repository Scan Summary
- Performed comprehensive scan of Biddable Community Edition codebase
- Project Overview:
  * Type: Open-source advertising platform for SMBs
  * Purpose: Multi-platform ad campaign management (Google, YouTube, Reddit, Meta)
  * Tech Stack: Next.js 14 + TypeScript + Supabase + shadcn/ui + Tailwind CSS
  * Package Manager: pnpm
  * License: AGPL-3.0
- Core Features Inventory:
  * Campaign Management - Create/manage campaigns with budgets, dates, platforms
  * Creative Assets - Upload images, create Google text ads (RSA/ETA), Reddit ads, AI-generated images
  * Audience Targeting - Demographic, geographic, interest-based targeting
  * Multi-Organization - RLS-secured organization-scoped data
  * Chat Widget - AI assistant integration
  * Agentic Buying System - Week 1 COMPLETE (13 agent API endpoints operational)
- Directory Structure Summary:
  * app/api/v1/agent/ - ðŸ†• Agent API endpoints (9 routes implemented)
  * app/api/settings/ - ðŸ†• API key management routes
  * app/ - Pages: assets, audiences, campaigns, profile, reporting, login, signup
  * components/ - 23 React components (UI, forms, previews, content pages)
  * lib/ - Utilities: agent-api-keys.ts, agent-api-middleware.ts, text-ads.ts, supabase clients
  * supabase/migrations/ - Database schema migrations
- Current Git Status:
  * Modified: ClaudeLog.txt, navigation.tsx, profile-content.tsx, middleware.ts, package.json, pnpm-lock.yaml
  * Untracked: agentic-buying-plan.txt, app/api/settings/, app/api/v1/, lib/agent-api-*.ts
- Recent Major Work: Agentic Buying System
  * Status: Week 1 COMPLETE âœ…
  * API key system with bcrypt hashing operational
  * 13 agent API endpoints built and tested:
    - 5 Campaign CRUD operations
    - 4 Asset operations (list, assignments)
    - 4 Audience operations (list, assignments)
  * API key management UI integrated into /profile page
  * Service role key architecture implemented (RLS bypass with app-level security)
  * Organization-scoped data isolation working correctly
  * Testing guide created (AGENT_API_TEST_GUIDE.md)
  * Comprehensive 3-week plan documented (agentic-buying-plan.txt)
- Implementation Status:
  * Week 1: âœ… COMPLETE - Core Agent API operational
  * Week 2: â¸ PENDING - Rate limiting, budget validation, audit logging, documentation
  * Week 3: â¸ PENDING - FastMCP server, hosted agent upgrade, Claude Desktop integration
- Database Schema:
  * 15 tables total (verified via current_db.sql)
  * Core tables: organizations, organization_members, campaigns, assets, audiences
  * Junction tables: campaign_assets, campaign_audiences
  * Auth tables: user_profiles, invites (auth.users managed by Supabase)
  * Agent tables: api_keys âœ…, agent_audit_log âœ…
  * ID types: campaigns/audiences (BIGINT), assets/organizations (UUID)
- Key Files:
  * README.md - Complete project documentation
  * agentic-buying-plan.txt - 3-week implementation master plan (1540 lines)
  * CLAUDE.md - Project instructions and rules
  * AGENT_API_TEST_GUIDE.md - Testing guide with curl examples
  * ClaudeLog.txt - This development log (966 lines)
- Technology Stack Details:
  * Frontend: React 18, Next.js 14 App Router, TypeScript 5
  * UI: Radix UI primitives, shadcn/ui components, Tailwind CSS 4
  * Forms: react-hook-form, Zod validation
  * Backend: Next.js API routes, Supabase Auth/DB/Storage
  * Security: bcryptjs, RLS policies, API key authentication
  * AI Integration: n8n webhooks for image generation
- All core features working and tested
- Ready for Week 2 implementation (rate limiting, budget controls, documentation)
